#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys


class Error(BaseException):
    message = 'Generic Error'

    def getMessage(self):
        return self.message


class CommandNotFound(ValueError, Error):
    def __init__(self, name, commands):
        msg = 'Subcommand "%s" not found. Registered subcommands are: %s' % (name, ', '.join(commands.keys()))
        print("positional arguments: ")
        for name, config in commands.items():
            print(' ' * 5 + "%-10s  %s" % (config['name'], config['description']))
        print("optional arguments:")
        print(' ' * 5 + "%-10s  %s" % ("-h, --help", "show this help message and exit"))
        print()
        self.message = msg


class Command:
    name = None

    def __init__(self, app):
        self.app = app

    @staticmethod
    def register_arguments(parser):
        pass

    def run(self):
        pass


def trim_docstring(docstring):
    """Trim a uniform amount of whitespace from all lines in the docstring after the first.

    See: https://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation
    """
    if not docstring:
        return ''
    # Convert tabs to spaces (following the normal Python rules)
    # and split into a list of lines:
    lines = docstring.expandtabs().splitlines()
    # Determine minimum indentation (first line doesn't count):
    indent = sys.maxsize
    for line in lines[1:]:
        stripped = line.lstrip()
        if stripped:
            indent = min(indent, len(line) - len(stripped))
    # Remove indentation (first line is special):
    trimmed = [lines[0].strip()]
    if indent < sys.maxsize:
        for line in lines[1:]:
            trimmed.append(line[indent:].rstrip())
    # Strip off trailing and leading blank lines:
    while trimmed and not trimmed[-1]:
        trimmed.pop()
    while trimmed and not trimmed[0]:
        trimmed.pop(0)
    # Return a single string:
    return '\n'.join(trimmed)


class App:
    args = None
    commands = {}

    def __init__(self):
        self.register_commands()
        parser = argparse.ArgumentParser(
            description=trim_docstring(self.__doc__),
            formatter_class=argparse.RawTextHelpFormatter
        )
        self.register_arguments(parser)
        self.parse_command_arguments(parser)
        self.args = parser.parse_args()

    def run(self):
        try:
            self.run_command(self.args.command)
        except Error as e:
            print(e.getMessage())

    def add_command(self, name, cls):
        self.commands[name] = {
            'name': name,
            'cls': cls,
            'description': cls.__doc__
        }

    def parse_command_arguments(self, parser):
        subparsers = parser.add_subparsers(dest='command')
        for name, config in self.commands.items():
            subparser = subparsers.add_parser(name, help=config['description'])
            config['cls'].register_arguments(subparser)

    def run_command(self, name):
        if name not in self.commands:
            raise CommandNotFound(name, self.commands)

        config = self.commands[name]
        instance = config['cls'](self)
        return instance.run()

    def register_commands(self):
        pass

    def register_arguments(self, parser):
        pass


def run_cli_cmd(cli_cmd_string):
    ssm_result = subprocess.Popen(
        [cli_cmd_string],
        stdout=subprocess.PIPE,
        shell=True
    )
    out, _ = ssm_result.communicate()
    return out.decode().rstrip()


class Info(Command):
    """Show the key count before/after the flush"""

    def run(self):
        domain_name = "{{ base_domain_name }}"
        print("---->current domain name : %s" % domain_name)

        redis_host = "redis.priv." + domain_name
        print("---->current redis host : %s" % redis_host)

        redis_cmd = "redis-cli -h " + redis_host +  " -p 6379 info keyspace | egrep -v '^[[:space:]]*#' | egrep -v '^[[:space:]]*$' | sed 's/^..*keys=\([0-9][0-9]*\),.*$/\\1/' "
        res = run_cli_cmd(redis_cmd)
        print("---->current info key space : %s" % res)


class Flush(Command):
    """Perform the flush"""

    def run(self):
        domain_name = "{{ base_domain_name }}"
        redis_host = "redis.priv." + domain_name
        print("---->current redis host : %s" % redis_host)
        redis_cmd = "redis-cli -h " + redis_host +  " -p 6379 info keyspace | egrep -v '^[[:space:]]*#' | egrep -v '^[[:space:]]*$' "
        pre_keys_num = run_cli_cmd(redis_cmd)
        print("---->current info key space : %s" % pre_keys_num)
        flush_cmd = "redis-cli -h " + redis_host + " -p 6379 flushall"
        _ = run_cli_cmd(flush_cmd)
        flushed_keys_num = run_cli_cmd(redis_cmd)
        print("---->info key space(after flush) : %s" % flushed_keys_num)


class DoRedis(App):
    def register_commands(self):
        self.add_command('show', Info)
        self.add_command('flush', Flush)


if __name__ == '__main__':
    app = DoRedis()
    app.run()
